<!doctype html>
<html>
<head>
	
	

<meta charset = "utf-8">
<title> How to Sumcheck</title>

<link rel = "stylesheet" href = "http://ShadowMonkey.pr/sass/main.min.css">

 


</head>

<body>
	<nav>
	<ul>
		<li><a href="/">Home</a></li>
		<li><a href="/zkproofs/">RandomWalks</a></li>
		<li><a href="/cryptocave/">CryptoCave</a></li>
		<li><a href="/zkworld/">ZKWorld</a></li>
		<li><a href="/mathnotes">Notes</a></li>
	</ul>
</nav>

	
	<h1>
		How to Sumcheck
		
			<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css"
	integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn"
    crossorigin="anonymous"
/>

<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"
	integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx"
    crossorigin="anonymous"
></script>



<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"
	integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
	crossorigin="anonymous"
	onload="
	renderMathInElement(document.body,{delimiters: [{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});
	"
></script>


		
	</h1>
	<p>May 1, 2023</p>
	<p>Prashanth Ramakrishna </p>
	<h2 id="outline">Outline</h2>
<ol>
<li>Motivation</li>
<li>What does the sumcheck protocol do?</li>
<li>Detailed multivariate sumcheck protocol
<ul>
<li>Discussion of polynomial descriptions</li>
<li>Discussion of $\mathsf{check}_{2}$&rsquo;s seeming redundancy</li>
<li>Discussion of $\mathsf{check}_{3}$</li>
</ul>
</li>
<li>Analysis of multivariate sumcheck protocol
<ul>
<li>Prover complexity (time, space, communication)</li>
<li>Verifier complexity (time, space, communication)</li>
<li>Security (completeness, soundness)</li>
</ul>
</li>
<li>How to get from an R1CS instance to a Sumcheck Instance
<ul>
<li>How does sumcheck figure into zero knowledge proof systems</li>
<li>Matrices to functions</li>
<li>Functions to ML polynomials</li>
<li>Query reduction to get sumcheck instance<br>
6.<strong>Hardware for multivariate sumcheck</strong></li>
<li><strong>FFT vs Sumcheck</strong></li>
</ul>
</li>
<li><strong>Univariate Sumcheck</strong></li>
<li><strong>Tensor Sumcheck</strong></li>
<li><strong>Sumchecks in different worlds</strong>
<ul>
<li><strong>Applications of sumchecks to commitments</strong></li>
<li><strong>Extending to rings and modules to give &ldquo;sumcheck-friendly&rdquo; commitments</strong></li>
<li><strong>Proof-of-Sumcheck??</strong></li>
</ul>
</li>
<li><strong>Arguing for a Sumchecky Worldview</strong></li>
</ol>
<h2 id="motivation">Motivation</h2>
<p>The Sumcheck Protocol (SCP) is an interactive proof that allows a prover $\mathcal{P}_{sc}$ to convince a verifier $\mathcal{V}_{sc}$ that some
multivariate polynomial $p$ with coefficients from finite field $\mathbb{F}$ yields a claimed value $T$ when its evaluations are summed over
the boolean hypercube $\lbrace 0,1 \rbrace^{w}$. Over the past several years the power of SCP has become incredibly pivotal in the development of
general purpose zero-knowledge proof systems, in both the univariate and multivariate cases. At the heart of many of these systems is an Interactive
Oracle Proof (IOP) whose attractive efficiency guarantees rely on creative applications of various SCP variants. In this post, we will introduce the
original SCP. This will serve as a foundation for understanding IOP constructions more generally.</p>
<h2 id="sumcheck-statement">SumCheck Statement</h2>
<p>More formally, the SCP proof $\Pi_{sc}$ consists of the interactive sumcheck prover-verifier pair $(\mathcal{P}_{sc}, \mathcal{V}_{sc})$ along with
a protocol context describing the sumcheck statement. To specify this context, we refer to the sumcheck instance
$\mathbb{I}_{sc} = (\mathbb{F}, p, T)$, where $p \in \mathbb{F}[\vec{X}]$ is characterized by its number of
variables $w$ and total degree $\mathsf{deg}(p) = d$. <strong>Recall that $\mathsf{deg}(p)$ denotes the maximum sum of powers in a single monomial term of
$p$</strong>. We associate a sumcheck instance with a sumcheck statement that $\mathcal{P}_{sc}$ proves to $\mathcal{V}_{sc}$. Treating $p$ as the witness,
we say that $\mathbb{I}_{sc}$ is in language $\mathcal{L}_{sc}$ if the associated sumcheck statement is indeed true.</p>
<p>$$ \begin{equation} T \overset{c}{=} \sum_{x_{1} \in \lbrace 0,1 \rbrace} \sum_{x_{2} \in \lbrace 0,1\rbrace} \ldots \sum_{v_{w} \in \lbrace 0,1\rbrace} p(x_{1}, \dots, x_{w}). \end{equation} $$</p>
<p>For the sake of brevity, let $\mathcal{B}^{w}$ denote $w$-dimensional boolean hypercube, allowing us to rewrite the above as</p>
<p>$$ \begin{equation} \mathbb{I}_{sc} = (\mathbb{F}, p, T) \Longleftrightarrow T \overset{c}{=} \sum_{\vec{b} \in \mathcal{B}^{w}} p(\vec{x}). \end{equation} $$</p>
<p>Fully, we say that given $\mathbb{I}_{sc} \in \mathcal{L}_{sc}$, $\Pi_{sc}(\mathbb{I}_{sc})$ succeeds if $\mathcal{P}_{sc}$ is able to convince
$\mathcal{V}_{sc}$ of $\mathbb{I}_{sc}$&rsquo;s corresponding claim. Clearly, one way for $\mathcal{P}_{sc}$ to proceed is by simply summing
the evaluations of $p$ over $\mathcal{B}^{w}$ then sending his result $T$ to $\mathcal{V}_{sc}$. $\mathcal{V}_{sc}$, who has a description of $p$,
can check $\mathcal{P}_{sc}$&rsquo;s work by redoing the computation and obtaining his own result $T&rsquo;$. $\mathcal{V}_{sc}$ accepts if and only if $T&rsquo; = T$.
However, this costs $\mathcal{V}_{sc}$ $O(2^{w})$ evaluations of $p$, exponential in the number of $p$&rsquo;s variables. Ideally, we wish to
harness the <em>power of interaction</em> in order to alleviate nearly all of the burden on $\mathcal{V}_{sc}$. Indeed, we will see not only that there exists
a $\mathcal{V}_{sc}$ linear in $w$, but also that the above sumcheck statement can be generalized to many different settings.</p>
<h2 id="the-sumcheck-protocol">The SumCheck Protocol</h2>
<p>The main idea behind the SCP is that $\mathcal{V}_{sc}$ can delegate work to $\mathcal{P}_{sc}$ by using randomly sampled elements from $\mathbb{F}$
to incrementally fix the variables of $p$. In each round, $\mathcal{P}_{sc}$ sends a univariate polynomial distilled from $p$ in the following way. Variables
fixed in previous rounds remain fixed and  $\mathcal{P}_{sc}$ sums $p$ over the remaining free dimensions of $\mathcal{B}^{w}$. $\mathcal{V}_{sc}$
dilligently performs continuous checks to verify consistency between polynomials received in the last round and the current one. After $w$ rounds,
she is left to evaluate $p$ at a single point in $\mathbb{F}^{w}$ consisting of the random elements previously sampled.</p>
<p>Cleanly describing the protocol requires clearly differentiating between variables fixed with randomness, the variable being isolated in the current
round, and the still free variables that will be dissolved by the prover. $r_{i}$ denotes the verifier sampled field element in round $i$ and
$\vec{r}_{i} = \langle r_{1}, \dots, r_{i} \rangle$ correspondingly gives the list of verifier sampled field elements since the beginning of the
protocol. $\vec{r_{i}}$ can also be thought of as variables $X_{1}, \dots, X_{i}$ fixed with verifier randomness. $X_{i}$ is the free variable for
the univariate polynomial computed and sent by $\mathcal{P}_{sc}$ in round $i$, while $\vec{x}_{i+1} = \langle X_{i+1}, \dots, X_{w} \rangle$
represents the variables that are &ldquo;collapsed&rdquo; in round $i$ by partial summation. In each round $w-1$ variables are either fixed with verifier randomness
or collapsed via partial summation. Lastly, we refer to individual degree $\mathsf{deg}_{i}(p)$ as the maximum power of $p$&rsquo;s $i$th variable.</p>
<blockquote>
<p>$$
\begin{aligned}
&amp;\textbf{Round 1.} &amp;&amp; &amp;&amp;\\
&amp;\mathcal{P}_{sc} &amp;&amp;\text{Channel} &amp;&amp;\mathcal{V}_{sc}\\
&amp;p_{1}(X_{1}) = \displaystyle{\sum_{\vec{x}_{2} \in \mathcal{B}^{w-1}} p(X_{1}, \vec{x}_{2})} &amp;&amp;\overset{p_{1}}{\longrightarrow} &amp;&amp;\mathsf{check_{1}}: p_{1}(0) + p_{1}(1) = T\\
&amp; &amp;&amp; &amp;&amp;\mathsf{check_{2}}: \mathsf{deg}(p_{1}) \le \mathsf{deg}_{1}(p)\\
&amp; &amp;&amp;\overset{r_{1}}{\longleftarrow} &amp;&amp;r_{1} \overset{\text{\textdollar}}{\leftarrow} \mathbb{F}\\
&amp;\textbf{Round 2.} &amp;&amp; &amp;&amp;\\
&amp;p_{2}(X_{2}) = \displaystyle{\sum_{\vec{x_{3}} \in \mathcal{B}^{w-2}} p(r_{1}, X_{2}, \vec{x_{3}})} &amp;&amp;\overset{p_{2}}{\longrightarrow} &amp;&amp;\mathsf{check_{1}}: p_{2}(0) + p_{2}(1) = p_{1}(r_{1})\\
&amp; &amp;&amp; &amp;&amp;\mathsf{check_{2}}: \mathsf{deg}(p_{2}) \le \mathsf{deg}_{2}(p)\\
&amp; &amp;&amp;\overset{r_{2}}{\longleftarrow} &amp;&amp;r_{2} \overset{\text{\textdollar}}{\leftarrow} \mathbb{F}\\
&amp;\textbf{Round $\bm{2 \le i &lt; w}$.} &amp;&amp; &amp;&amp;\\
&amp;p_{i}(X_{i}) = \displaystyle{\sum_{\vec{x}_{i+1} \in \mathcal{B}^{w-i}} p(\vec{r}_{i-1}, X_{i}, \vec{x}_{i+1})} &amp;&amp;\overset{p_{i}}{\longrightarrow} &amp;&amp;\mathsf{check_{1}}: p_{i}(0) + p_{i}(1) = p_{i-1}(r_{i-1})\\
&amp; &amp;&amp; &amp;&amp;\mathsf{check_{2}}: \mathsf{deg}(p_{i}) \le \mathsf{deg}_{i}(p)\\
&amp; &amp;&amp;\overset{r_{i}}{\longleftarrow} &amp;&amp;r_{i} \overset{\text{\textdollar}}{\leftarrow} \mathbb{F}\\
&amp;\textbf{Round $\bm{w}$.} &amp;&amp; &amp;&amp; \\
&amp; p_{w}(X_{w}) = p(\vec{r_{w-1}}, X_{w}) &amp;&amp; \overset{p_{w}}{\longrightarrow} &amp;&amp;\mathsf{check_{1}}: p_{w}(0) + p_{w}(1) = p_{w-1}(r_{w-1})\\
&amp; &amp;&amp; &amp;&amp; \mathsf{check_{2}}: \mathsf{deg}(p_{w}) \le \mathsf{deg}_{i}(p) \\
&amp; &amp;&amp; &amp;&amp; r_{w} \overset{\text{\textdollar}}{\leftarrow} \mathbb{F} \\
&amp; &amp;&amp; &amp;&amp; \mathsf{check_{final}}: p_{w}(r_{w}) = p(\vec{r_{w}}) \\
&amp; &amp;&amp; &amp;&amp; \text{Return 1 iff checks pass} \\
\end{aligned}
$$</p>
</blockquote>
</div>
<p>Though the conceit of the protocol is intuitive enough &ndash; using randomness to recursively fix variables allows for round complexity linear in $w$ &ndash;
there is some hidden machinery here that should be discussed.</p>
<p><strong>Polynomial Descriptions</strong>. The SCP is agnostic to the description $\mathcal{P}_{sc}$ chooses for each $p_{i}$ he sends. However, in practice, one
has the choice to implement this description as either coefficient or evaluation form. Recall that the latter follows from the fact that each $p_{i}$
is a univariate polynomial and can therefore be specified by $\mathsf{deg}_{i}(p + 1)$ evaluations over $\mathbb{F}$, canonically be taken as the
evaluations of $p_{i}$ on the set $[0, \mathsf{deg}(p_{i})+1] \subseteq \mathbb{F}$.Often, as will be seen shortly, we are interested in relatively
low-degree polynomials and as such might enjoy a communication reduction only having to send $d_{i}$ field elements per round. Still, sending polynomials
in evaluation form require interpolation from the verifier before evaluatng each $p_{i}(r_{i})$. If optimizing for verifier efficiency, one would have
the prover interpolate, reducing verifier work in the first $w-1$ rounds only to sampling random field elements and evaluating univariate polynomials on them.</p>
<p><strong>Why $\mathsf{check_{2}}$ matters</strong>. Clearly, $\mathsf{check_{1}}$ exists to ensure consistency between polynomials sent in consecutive rounds.
At first glance however, $\mathsf{check_{2}}$ seems redundant, since $\mathcal{V}_{sc}$ can simply inspect the length of the RS codeword sent in each
round. Keep in mind, though, that the above protocol is written with some level of versatility in mind. The purpose of $\mathsf{check_{2}}$
is for $\mathcal{V}_{sc}$ to determine the message she recieves in a particular round is valid. In this case, the enforcement mechanism is a
low-degree test that $\mathcal{V}_{sc}$ is assumed to have access to. However, in other settings the enforcement mechanism may be an alternate form
of proximity test for a different code. Additionally, when pursuing zero-knowledge, messages may be committed to, in which case $\mathcal{V}_{sc}$ may
require yet another enforcement mechanism that either follows from or integrates with the commitment scheme in use to ensure the validity of the
underlying polynomial encoding.</p>
<p><strong>Costing $\mathsf{check_{final}}$</strong>. Assume that verifier has oracle access to the $p$.</p>
<details>
 <summary><strong>Remark.</strong> <em>Generalizing Beyond $\mathcal{B}^{w}$</em></summary>
 <blockquote>
<p>The sumcheck protocol can be generalized to any subset $S \subset \mathbb{F}$ in the straightforward way by replacing $\mathcal{B}^{w}$ with
$S^{w}$. Then in round $1$, the prover must compute the partial sume $p_{1} = \sum_{\vec{x}_{2} \in s^{w-1}} p(X_{1}, \vec{x}_{2})$ and the
verifier must accodingly check that $\sum_{s \in S}p_{1}(s) = T$. In general, the only modification is that for round $i$, $\mathsf{check_{1}}$
asserts
$$\sum_{s \in S}p_{i}(s) = p_{i-1}(r_{i-1})$$
The verifier&rsquo;s work increases expectedly by a constant factor.</p>
</blockquote>

</details>

<h2 id="guarantees-and-theoretical-relevance">Guarantees and Theoretical Relevance</h2>
<p>The power of the SCP comes from (1) it&rsquo;s attractive efficiency metrics, allowing a seemingly expensive computation to be verified with relatively
little work while only imposing a minor overhead to a prover implementing the best strategy to actually perform the computation (which, of course,
must be done by some party at some point) and (2) the fact that a wide array of problems can naturally be cast as sumcheck instance. These two facts
make the SCP an incredibly versatile and indespensible tool and encourage one to develop a <em>sumchecky worldview</em>. In this section, I&rsquo;ll briefly
discuss the complexity of the SCP as well as the standard security properties of completeness and soundness.</p>
<p><strong>Complexity</strong>. First, let&rsquo;s consider $\mathcal{P}_{sc}$. In each of the $w$ rounds, he must compute a partial sum of $p$ over a boolean hypercube of
reduced dimensionality. This ammounts to $\sum_{i = 1}^{w} |\mathcal{B}^{i}| = 2^{w+1}$ evaluation of $p$, only a constant factor more than the work
of summing the evaluations of $p$ over $\mathcal{B}^{w}$. He must then evaluate the resulting univariate polynomials on $\mathsf{deg}_{i}(p) + 1$ points
from $\mathbb{F}$ for each round $i$, resulting in $w + \sum_{i = 1}^{w} \mathsf{deg}_{i}(p)$ number of evaluations and field elements
that $\mathcal{P}_{sc}$ communicates throughout the protocol. <strong>still need to discuss prover space</strong></p>
<p>Next, we consider $\mathcal{V}_{sc}$, who&rsquo;s work is neatly characterized by $w$ applications of $\mathsf{check_{1}}$ and $\mathsf{check_{2}}$,
followed by a single application of $\mathsf{check_{final}}$.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Prover Runtime</th>
<th style="text-align:center">Prover Space</th>
<th style="text-align:center">Prover Communication</th>
<th style="text-align:center">Verifier Runtime</th>
<th style="text-align:center">Verifier Space</th>
<th style="text-align:center">Verifier Communication</th>
<th style="text-align:center">Round Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$O(2^{w})$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(w)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(d)$</td>
<td style="text-align:center">$O(d)$</td>
</tr>
</tbody>
</table>
<details>
 <summary><strong>Remark.</strong> <em>Why Space Matters</em></summary>
 <blockquote>
<p>Space should matter for resource constrained devices. Where are sumchecks actually getting used?</p>
</blockquote>

</details>

<p><strong>Completeness</strong>. Recall that completeness requires that if $\mathbb{I}_{sc} \in \mathcal{L}_{sc}$, then $\mathcal{V}_{sc}$ will accept with
probability 1. In the context of the SCP, this means that $\mathsf{check_{1}}$ and $\mathsf{check_{2}}$ pass in every round and $\mathsf{check_{final}}$
passes in the final round. The proof can be constructed inductively on the number of $p$&rsquo;s variables. In the base case, $p$ will be a constant
function. If $p = T$, then $\mathcal{V}_{sc}$ will accept. Next, all that one needs to show is that a valid sumcheck instance for a polynomial with $w &gt; 0$
variables can be reduced to a valid sumcheck instance for a polynomial with $w-1$ variables.</p>
<p><strong>Soundness</strong>. Amazingly, nearly all of the security of PIOP-based proof systems is derived from a single lemma, whose ubiquity cannot be overstated: the
Shwartz-Zippel lemma, a probabilistic tool for polynomial zero testing and, consequently, identity testing &ndash; given $p_{1}, p_{2} \in
\mathbb{F}[\vec{X}]$ of the same total degree, testing whether $p_{1} = p_{2}$ is equivalent to testing whether $p_{1} - p_{2} = p_{3} = 0$.</p>
<p><strong>Shwartz-Zippel Lemma (SZL):</strong> Let $p \in \mathbb{F}[X_{1}, \dots, X_{w}]$ be a <em>non-zero</em> $w$-variate polynomial over field $\mathbb{F}$. Further,
let $S \subseteq \mathbb{F}$ be a finite subset of $\mathbb{F}$. Then the probability that $p$ evaluates to $0$ on some uniformly random point
$\vec{r} \in S^{w}$ is given by</p>
<p>$$\Pr[p(r_{1}, \dots, r_{w}) = 0] \le \frac{d}{\lvert S \rvert}$$</p>
<p>Recall that soundess error $\varepsilon_{sc}$ aims to capture the probability that a cheating prover $\tilde{\mathcal{P}_{sc}}$ with an invalid
sumcheck instance $\tilde{\mathbb{I}}_{sc} = (\mathbb{F}, \tilde{p}, T) \not\in \mathcal{L_{sc}}$ will succeed. $\varepsilon_{sc}$
is given by,</p>
<p>$$\begin{equation}\varepsilon_{sc} \le \frac{\sum_{i=1}^{w}\mathsf{deg}_{i}(p)}{|\mathbb{F}|}\end{equation}$$.</p>
<p>The proof again proceeds inductively on $w$, but can be seen intuitively since, by SZP, there are at most $\frac{d}{\mathbb{F}}$
points $r_{i}$ that $\mathcal{V}_{sc}$ can sample in round $i$ for which $\tilde{\mathcal{P}_{sc}}$&rsquo;s malicious polynomial $\tilde{p}_{i}(r_{i}) =
p_{i}(r_{i})$ and will therefore pass $\mathsf{check_{1}}$ and $\mathsf{check_{2}}$. The number of rounds being $w$ results in the given bound for
$\varepsilon_{sc}$ for a $\tilde{\mathcal{P}}_{sc}$&rsquo;s sucess. Note that a protocol is considered sound if $\varepsilon$ is sufficiently small,
usually with respect to some security parameter. This requires choosing a big enough $\mathbb{F}$. In general, it is good enough to choose
$|\mathbb{F}| = O(\mathsf{poly}(|\mathcal{B}^{w}|))$.</p>
<details>
 <summary><strong>Remark.</strong> <em>How to Batch</em></summary>
 <blockquote>
<p>The sumcheck protocol is easily extended to the sumcheck for a batch of polynomials $\lbrace p_{i}\rbrace$ for $i \in [0,L]$ by letting the verifier
sample a random vector $\vec{\lambda} \in \mathbb{F}^{L}$, and a subsequent sumcheck protocol for the random linar combination
$$\hat{p}(\vec{X}) = p_{0}(\vec{X}) + \sum_{i = 1}^{L} \lambda_{i} \cdot p_{i}(\vec{X}).$$
The soundness error increases only slightly
$$\varepsilon_{bsc} \le \frac{1 + \sum_{i = 1}^{w}\mathsf{deg}_{i}(p_{i})}{|\mathbb{F}|}$$</p>
</blockquote>

</details>

<details>
 <summary><strong>Remark.</strong> <em>Generalizing Beyond $\mathcal{B}^{w}$</em></summary>
 <blockquote>
<p>The sumcheck protocol can be generalized to any suitable subset of $\mathbb{F}$ in the following way:</p>
</blockquote>

</details>

<ol>
<li><a href="https://people.cs.georgetown.edu/jthaler/blogpost.pdf">The Unreasonable Power of the SumCheck Protocol</a></li>
<li><a href="https://eprint.iacr.org/2022/1530.pdf">Multivariate Lookups based on Logarithmic Derivatives</a></li>
</ol>
<h2 id="multivariate-scp-for-zero-knowledge">Multivariate SCP for Zero Knowledge</h2>
<p>The SCP has been instrumental in developing succinct arguments of knowledge that can be augmented with zero-knowledge using cryptographic techniques. The
image below, taken from slides developed by <strong>link talk</strong> Setty, summarizes three approximate eras (overlapping) of succinct argument constructions and,
by extension, zero knowledge proof systems. Here, I will attempt to give an understanding of where sumcheck instances arise in the process of
generating a zero knowledge proof and how they contribute to realizing efficiency.</p>
<p><img src="/succinctargs.jpg" alt="succinctargs" title="succinct args"></p>
<p>Recall briefly the basic flow from computation to zero knowledge proof. A prover wishes to perform some computation $\mathsf{Comp}$ with
input $\mathsf{Input}$ and produce a proof that his work is correct. $\mathsf{Comp}$ can be equivalently expressed as an algebraic circuit
$\mathcal{C}$ with input $I_{\mathcal{C}}$. The circuit naturally represents a relation that defines a language $\mathcal{L}_{\mathcal{C}}$. Here,
we will differentiate the private part of the relation as the input witness $I_{\mathcal{C}}$ and the public part as the circuit itself,
$\mathcal{C}$. We say that $(\mathcal{C}, I_{\mathcal{C}}) \in \mathcal{L}_{\mathcal{C}}$ if $\mathcal{C}(I_{\mathcal{C}}) = 1$. There are a number
of paths from this juncture to a zero knowledge proof. One can work directly over the circuit itself and produce a proof using a technique known as
multiparty computation in-the-head (MPC-ITH). One can also proceed through various methods of <em>arithmetization</em> that translate $\mathcal{C}$ from a
circuit to a constraint system and $I_{\mathcal{C}}$ to a satisfying assignment for the system. Zero-knowledge is then achieved by cryptographically
commiting to an assignment, then arguing that the opening of the commitment (i.e, the assignment contained within) is indeed satisfying. I will focus
here on the popular Rank One Constraint System (R1CS), which takes $\mathcal{C}$ to a set of public coefficient matrices $A, B, C \in \mathbb{F}^{n \times n}$
and $I_{\mathcal{C}}$ to an assignment $z \in \mathbb{F}^{n}$. Recall that $\mathbb{I}_{\mathsf{R1CS}}((A,B,C), z) \in \mathcal{L}_{\mathsf{R1CS}}$ iff</p>
<p>**here I might be talking about arithmetization incorrectly. Arithmetization formally is the process of taking a</p>
<p>$$ Az_{\mathcal{C}} \circ Bz = Cz.$$</p>
<p>Now, what is left is to take this statement, which is fundamentally one about the equality of vectors in $\mathbb{F}^{n}$, and turn it one regarding
polynomials &ndash; in particular, a sumcheck statement. This is the transformation which we subject to magnification and that has analogues across nearly
all proof systems. Committing to $z$ allows for the possibility of realizing zero-knowledge in the &ldquo;commit-and-prove&rdquo; paradigm. Summarizing the journey until now:  <br>
$$(\mathsf{Comp}, \mathsf{Input})$$
$$\Updownarrow$$
$$(\mathcal{C}, I_{\mathcal{C}}) \longrightarrow \mathbb{I}_{\mathsf{R1CS}} \rightarrow \mathbb{I}_{sc}$$
$$\Updownarrow$$
$$\mathcal{L}_{\mathcal{C}} \longrightarrow \mathcal{L}_{\mathsf{R1CS}} \longrightarrow \mathcal{L}_{sc}$$</p>
<p>We will roughly follow the tack taken by Spartan, which in my view provides a natural insight into how the SCP is used in the construction of
PIOP-based proof systems. At a high level, the transformation from an R1CS instance to a sumcheck instance consists of the following steps:</p>
<blockquote>
<ol>
<li>Interpret matrix-vector operations as operations on functions over the boolean hypercube</li>
<li>Transform the resulting statement into one regarding polynomials using multilinear extensions.</li>
<li>Perform query reduction in order to obtain a sumcheckable statement.</li>
</ol>
</blockquote>
<p>Let $s = \lceil\log(n)\rceil$. For any $n$-length vector, we can use an $s$-length binary string to index its entries. Alternatively, this can be
thought of as unpacking indices (as field elements) into bits. Indeed a tensor of any degree can be interpreted as as a map from the binary strings used to
index an entry to the entry itself. As such, we consider the R1CS coefficient matrices and witness as the following maps:</p>
<p>$$A, B, C: \lbrace0, 1\rbrace^{s} \times \lbrace0,1\rbrace^{s} \longrightarrow \mathbb{F}$$
$$z: \lbrace 0,1 \rbrace^{s} \longrightarrow \mathbb{F}.$$</p>
<p>The R1CS relation can now be naturally expressed in the alternate interpretation as summations of functions evaluated over the $s$-dimensional boolean
hypercube. $\forall (i, j) \in [1,n] \times [1, n]$ let $(\vec{x}, \vec{y}) \in \mathcal{B}^{s} \times \mathcal{B}^{s}$ be the corresponding binary
unpacking. Then,</p>
<p>$$
\begin{aligned}
&amp; &amp;&amp;Az \circ Bz &amp;&amp;= Cz\\
&amp;\implies &amp;&amp;\sum_{i \in [1,n]} \vec{a}_{i}z_{i} \circ \sum_{i \in [1,n]} \vec{b}_{i}z_{i} &amp;&amp;= \sum_{i \in [1,n]} \vec{c}_{i}z_{i} \\
&amp;\implies &amp;&amp;\left[\left(\sum_{j\in[1,n]} a_{1j}z_{j} \times \sum_{j\in[1,n]} b_{1j}z_{j}\right), \dots, \left(\sum_{j\in[1,n]} a_{njz_{j}} \times \sum_{j\in[1,n]} b_{nj}z_{j}\right)\right]^{\bm{T}} &amp;&amp;= \left[\sum_{j\in[1,n]}c_{1j}z_{j}, \dots, \sum_{j\in[1,n]}c_{nj}z_{j}\right]^{\bm{T}}\\
&amp;\implies &amp;&amp;\forall i \in [1,n], \left(\sum_{j\in[1,n]} a_{ij}z_{j}\right) \times \left(\sum_{j\in[1,n]} b_{ij}z_{j}\right) &amp;&amp;= \sum_{j\in[1,n]}c_{ij}z_{j}\\
&amp;\implies &amp;&amp;\forall \vec{x} \in \mathcal{B}^{s}, \left(\sum_{\vec{y}\in\mathcal{B}^{s}}A(\vec{x},\vec{y})z(\vec{y})\right) \times \left(\sum_{\vec{y}\in\mathcal{B}^{s}}B(\vec{x},\vec{y})z(\vec{y})\right) &amp;&amp; =\sum_{\vec{y}\in\mathcal{B}^{s}}C(\vec{x},\vec{y})z(\vec{y})\\
\end{aligned}
$$</p>
<p>Next, we transform our relation regarding tensors into a relation regarding polynomials and in doing so, inch closer to producing a sumcheckable
statement. In order to do this, we take the unique multilinear extensions of maps $A, B, C, Z$, denoted $\tilde{A},\tilde{B}, \tilde{C}, \tilde{z}$.
Recall that a multilinear polynomial is a polynomial whose individual degree is at most one in each variable and that every $w$-variate function $f$
has a unique multilinear extension $\tilde{f}$ that agrees with $f$ on $\mathcal{B}^{w}$ but whose full domain is $\mathbb{F}$. Rephrasing our statement
using multilinear extensions, we have</p>
<p>$$\forall x \in \mathcal{B}^{s}, \tilde{F}(\vec{x}) = \left(\sum_{\vec{y}\in\mathcal{B}^{s}}\tilde{A}(\vec{x},\vec{y})\tilde{z}(\vec{y})\right)\left(\sum_{\vec{y}\in\mathcal{B}^{s}}\tilde{B}(\vec{x},\vec{y})\tilde{z}(\vec{y})\right) - \sum_{\vec{y}\in\mathcal{B}^{s}}\tilde{C}(\vec{x},\vec{y})\tilde{z}(\vec{y}) = 0.$$</p>
<p>Still, however, the original R1CS statement has not been recast in sumcheckable form. Here, we can deploy a deploy a trick known as <em>query reduction</em>
that will make use of the MLE basis polynomial</p>
<p>$$ \tilde{\mathsf{eq}}(\vec{x}, \vec{e}) = \prod_{i = 1}^{s} x_{i}e_{i} + (1 - x_{i})(1 - e_{i}).$$</p>
<p>The utility of $\tilde{\mathsf{eq}}$ stems from the fact that when $\vec{x} = \vec{e} \in \mathcal{B}^{s}$, $\tilde{\mathsf{eq}} = 1$ and when $\vec{x}
\ne \vec{e}$, $\tilde{\mathsf{eq}} = 0$.</p>
<p>$$Q(t) = \sum_{x \in \mathcal{B}^{s}} \tilde{F}(x)\tilde{\mathsf{eq}}(x, t)$$</p>
<p>Notice that simply by fixing $t$ with a randomly sampled element $\tau$, we obtain a sumcheckable statement where $T = Q(\tau)$ and $p(\vec{X}) =
\tilde{F}(\vec{X})\tilde{\mathsf{eq}}(\vec{X}, \tau)$.</p>
<p><strong>Theoretical Relevance of SCP.</strong> IP = PSPACE, GKR Protocol, etc. etc. But don&rsquo;t go too deep. No need to explain anything here.</p>
<ol>
<li><a href="https://eprint.iacr.org/2019/550.pdf">Spartan: Efficient and general-purpose zkSNARKs without trusted setup</a></li>
<li><a href="https://eprint.iacr.org/2019/953.pdf">Plonk: Permuations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</a></li>
</ol>
<h2 id="hardware-optimized-sumcheck">Hardware-Optimized Sumcheck</h2>
<p>Because the SCP is such a central component to modern proof systems, it is important to consider the efficiency of its implementation with respect to
various hardware options. Sumcheck hardware acceleration is an extremeley understudied problem and is an important opportunity for further work.
What&rsquo;s interesting here is that the highly local nature of the memory retrievals for the prover actually make the sumcheck quite amenable to hardware
acceleration. This is in contrast to FFTs, which are difficult to accelerate in this way. This is one of the main arguments for why sumcheck-based
proof systems are the best bet for concrete efficiency.</p>
<p><strong>Memory Retrieval.</strong></p>
<p><strong>Hardware Optimizations.</strong></p>
<ol>
<li><a href="https://hackmd.io/@bychen92/H1JDAAMoo">Hardware Optimizations for SumCheck</a></li>
<li><a href="https://hackmd.io/@omershlo/rJhgKJPtj">Hardware Friendliness of HyperPlonk</a></li>
<li><a href="https://eprint.iacr.org/2015/1243.pdf">Zebra: Verifiable ASICs</a></li>
<li><a href="https://eprint.iacr.org/2017/242.pdf">Giraffe: Full Accounting of Verifiable Outsourcing</a></li>
</ol>
<h2 id="univariate-sumcheck">Univariate Sumcheck</h2>
<p>So far, we have seen how succinct arguments can be built from multivariate polynomials. Currently though, the most concretely efficient
proof systems are constructed not from multivariate polynomials but instead from univariate ones. And, where univariate polynomials are used, a
univariate sumcheck is needed. The univariate sumcheck protocol $\Pi_{usc} = (\mathcal{P}_{usc}, \mathcal{V}_{usc})$ first appeared in Aurora for
this very reason &ndash; that is, to verify univariate sumcheck instances of the form $\mathbb{I}_{usc} = (\mathbb{F}, H, f, \mu)$ that claim</p>
<p>$$\sum_{a \in H}f(a) \overset{c}{=} \mu.$$</p>
<p>Here, a summation domain $H \subseteq \mathbb{F}$ is specified. The only condition on $H$ is that it must be either an additive or multiplicative
subgroup of $\mathbb{F}$. This restriction is necessary because $\Pi_{usc}$ relies on facts about polynomial summations over these domains. The
development of such facts has, over time, corresponded to the expansion of sumcheck beyond the boolean hypercube and even finite fields.</p>
<p><strong>Multiplicative Subgroup Summation Lemma (MSS)</strong>. Let $H$ be a multiplicative subgroup of finite field $\mathbb{F}$. Further, let $f \in \mathbb{F}[
X]$ such that $\mathsf{deg}(f) &lt; |H|$. Then,</p>
<p>$$\begin{equation}\sum_{a \in H} f(a) = f(0) \cdot |H|\end{equation}$$</p>
<details>
 <summary><strong>Proof.</strong></summary>
 <blockquote>
<p>If $f \in \mathbb{F}[X]$ such that $\mathsf{deg}(f) &lt; |H|$, then it can be written as $f(X) = \sum_{i = 0}^{|H|-1} c_{i}X^{i}$ where $c_{0}, \dots, c_{1}$
are coefficients from $\mathbb{F}$. Summing over $H$, we can write $\sum_{a \in H}\sum_{i = 0}^{|H| - 1} c_{i}a^{i}$. Next, switching the order of summation,
we have $\sum_{i = 0}^{|H|-1}\sum_{a \in H} c_{i}a^{i}$. Because $H$ is a multiplicative subgroup, it is cyclic, and its elements can be enumerated
as powers of a root of unity $H = \langle \omega \rangle = \lbrace 1, \omega, \omega^{2}, \dots, \omega^{|H|-1} \rbrace$. As such, we rewrite our
summation accordingly and simplify in order to disappear all terms except those related to the $f(0) = c_{i}$. The full derivation is as follows:</p>
<p>$$\begin{aligned}
\sum_{a \in H}f(a) &amp;= \sum_{a \in H}c_{0} + \left( \sum_{a \in H} \sum_{i = 1}^{|H|-1}c_{i}x^{i}\right) \\
&amp;= c_{0} \cdot |H| + \left(\sum_{j = 0}^{|H|-1}\sum_{i = 1}^{|H|-1}c_{i}(\omega^{j})^{i}\right) \\
&amp;= c_{0} \cdot |H| + \left(\sum_{i = 1}^{|H|-1}c_{i}\sum_{j = 0}^{|H|-1} (\omega^{i})^{j} \right) \\
&amp;= c_{0} \cdot |H| + \sum_{i = 1}^{|H|-1} c_{i} \frac{1 - (\omega^{i})^{|H|}}{\omega^{i} - 1} \\
&amp;= c_{0} \cdot |H|
\end{aligned}$$.</p>
<p>Recall that for some $r$, the geometric series $\sum_{i = 0}^{n - 1} r^{i} = \frac{1 - r^{n}}{1 - r}$. Letting $r = \omega^{i}$, we see that the
numerator of the geometric series evaluates to $0$, since $\omega^{i}$ is a $|H|$-root of unity and as such $(\omega^{i})^{|H|} = 1$. We avoid
degenerate denominators by only letting $i \in [1, |H|-1]$.</p>
</blockquote>

</details>

<p>We begin by noticing that any polynomial with degree less than $|H|$ has a unique decomposition with respect to the vanishing polynomial
$\mathbb{Z}_{H}$. Recall that $\mathbb{Z}_{H}$ is simply the polynomial whose roots are elements of $H$ and therefore <em>vanishes</em> when evaluated
anywhere on $H$. Specifically, there exist polynomials $g$ and $h$ such that</p>
<p>$$f = g + \mathbb{Z}_{H} \cdot h$$</p>
<p>where $\mathsf{deg}(g) &lt; |H|$ and $\mathsf{deg}(h) &lt; \mathsf{deg}(f) - |H|$. This allows us to reinterpret $\mathbb{I}_{sc}$ in a way that makes MSS
relevant.</p>
<p>$$\sum_{a \in H}f(a) = \sum_{a \in H}g(a) + \mathbb{Z}_{H}(a) \cdot h(a) = \sum_{a \in H}g(a).$$</p>
<blockquote>
<ol>
<li>$\mathcal{P}_{usc}$ computes $\hat{g}&rsquo;, \hat{h}$, and $c_{|H|-1} \in \mathbb{F}$ such that:
<ul>
<li>$\hat{h} \in \mathsf{RS}\left[L, \frac{D - |H|}{|L|}\right], \hat{g}&rsquo; \in \mathsf{RS}\left[L, \frac{|H|-1}{|L|}\right]$</li>
<li>$\hat{f} = \hat{g}&rsquo; + c_{|H|-1}X^{|H|-1} +\mathbb{Z}_{H}\hat{h}$</li>
</ul>
</li>
<li>$\mathcal{P}_{usc}$ sends the econding of $\hat{h}$, $\hat{h}|_{L} \in \mathsf{RS}\left[L, \frac{D-|H|}{|L|}\right]$</li>
<li>$\mathcal{V}_{usc}$ computes $\hat{p}(x) = \mathcal{E}\hat{f}(X) - \mu X^{|H|-1} - \mathcal{E}\mathbb{Z}_{H}\hat{h}(X)$.</li>
<li>$\mathcal{V}_{usc}$ accepts iff $\hat{p}|_{L} \in \mathsf{RS}\left[L, \frac{|H|-1}{|L|}\right]$</li>
</ol>
</blockquote>
<ol>
<li><a href="https://eprint.iacr.org/2018/828.pdf">Aurora: Transparent Succinct Arguments for R1CS</a></li>
<li><a href="https://eprint.iacr.org/2019/1047.pdf">Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS</a></li>
</ol>
<h2 id="tensor-sumcheck">Tensor Sumcheck</h2>
<blockquote>
<p>The Tensor Sumcheck is originally developed in order to provide alternate proof of the IP Theorem. This alternate proof establishes the intuition
that resorting to algebra in classical proofs of the IP Theorem is useful because low-degree polynomials are good error correcting codes, and
encoding the truth table of quantifiable boolean formulas allows a verifier to decide satisfiability efficiently by simply querying a random
coordinate of the resulting encoding.</p>
<p>The tensor product operation generalizes the process of moving from univariate polynomials to multivariate polynomials. Univariate polynomials can
be viewed as error correcting codes. Multivariate polynomials can then be obtained by applying the tensor product oepration to univeriate
polynomials. Error correcting codes obtained via the tensor product operation are called <em>tensor codes</em>.</p>
<p>The SumCheck protocol works for multivariate polynomials, but in fact can work for any tensor code. Tensor codes have the following property: A code
word $c$ of a tensor code can be viewed as a function from some hypercube $[\ell]^{m} \longrightarrow \mathbb{F}$ such that if a function $f$ is
defined by summation of $c$ over the hypercube, then $f$ itself is a codeword of some other error-correcting code. That is, the property that makes
$\Pi_{msc}$ function is that multivariate polynomials are tensor codes.</p>
<p>The alternate proof of the IP Theorem proceeds by replacing the polynomial obtained by arithmetization with a tensor codeword that agrees with the
formula on the boolean hypercube. The replacement requires generalizing the arithmetization technique to work with general error correcting codes
instead of just polynomials. This is done by constructing <em>multiplication codes</em>, error correcting codes that emulate polynomial multiplication.</p>
<p>Our generalization of the sum-check protocol says roughly the following: Let $c$ be a codeword of code $C^{m}$, and let $d$ be a codeword of a code
$D^{m}$ that is consistent with the messay encoding by $c$. Then, the sum-check protocol reduces the task of verifying a claim of the form $c(\vec{i}) =
u$ to the task of verifying a claim of the form $d(\vec{r}) = v$ (where $\vec{i}$ and $\vec{r}$ are coordinates of $c$ and $d$ respectively, and $u,
v \in \mathbb{F}$).</p>
</blockquote>
<ol>
<li><a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=ae74cd1558d2b636ce931d6437cba6e3da9de29e">IP = PSPACE using Error Correcting Codes</a></li>
<li><a href="https://eprint.iacr.org/2021/1673.pdf">Proving as Fast as Computing: Succinct Arguments with Constant Prover Overhead</a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ol>
<h2 id="sumchecks-in-other-worlds">Sumchecks in Other Worlds</h2>
<p>Interestingly, by porting the SCP into the context of modules, the sumcheck strategy of binding variables to randomness can be abstracted to encompass
folding arguments for openings to committments in various settings. Of course, when doing this, a number of adjustments must be made to ensure
security.</p>
<p><strong>Give visual of sumcheck arguments</strong></p>
<ol>
<li><a href="https://eprint.iacr.org/2017/305.pdf">A Zero Knowledge Sumcheck and Its Applications</a></li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<table>
<thead>
<tr>
<th style="text-align:center">$\Pi_{msc}$</th>
<th style="text-align:center">$\Pi_{usc}$</th>
<th style="text-align:center">$\Pi_{tsc}$</th>
<th style="text-align:center">$\Pi_{csc}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$O(2^{w})$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="notational-reference">Notational Reference</h2>
<ol>
<li>
<p>$\mathcal{P}_{sc}$: SumCheck Prover</p>
</li>
<li>
<p>$\mathcal{V}_{sc}$: SumCheck Verifier</p>
</li>
<li>
<p>$\mathbb{I}_{sc}$: SumCheck Instance</p>
</li>
<li>
<p>$\Pi_{sc} = \langle \mathcal{P}_{sc}, \mathcal{V}_{sc}, \mathbb{I}_{sc} \rangle$: Interactive SumCheck Argument</p>
</li>
<li>
<p>$\mathbb{I}_{sc} = (\mathbb{F}, p, w, )$:</p>
</li>
<li>
<p>$\mathcal{B}^{w}$   : $w$-dimensional boolean hypercube</p>
</li>
<li>
<p>$\alpha \overset{c}{=} \beta$ : $\alpha$ is claimed to equal $\beta$</p>
</li>
<li>
<p>$(\mathsf{Comp}, \mathsf{Input})$: Computation and Input pair</p>
</li>
<li>
<p>$(\mathcal{C}, I_{\mathcal{C}})$: Circuit and Input pair</p>
</li>
<li>
<p>$\mathcal{L}_{sc}$: Sumcheck language</p>
</li>
<li>
<p>$\mathcal{L}_{C}$: valid assignments for compuation $C$</p>
</li>
<li>
<p>MSCP = multivariate sumcheck protocol, USCP = univariate sumcheck protocol, TSCP = tensor sumcheck protocol</p>
</li>
</ol>
<h1 id="references">References</h1>
<ol>
<li><a href="https://eprint.iacr.org/2021/333.pdf">Sumcheck Argumetns and their Applications</a></li>
<li><a href="https://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.pdf">Proofs, Arguments, and Zero-Knowledge</a></li>
<li><a href="https://people.cs.georgetown.edu/jthaler/blogpost.pdf">The Unreasonable Power of the SumCheck Protocol</a></li>
<li><a href="https://people.eecs.berkeley.edu/~alexch/docs/CS294-S2017/lecture-01.pdf">Introduction to Interactive Proofs &amp; The Sumcheck Protocol</a></li>
</ol>


	
	<footer>
		Website made by Prashanth Ramakrishna in 2023
	</footer>


</body>
</html>
