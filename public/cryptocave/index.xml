<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cryptocaves on ShadowMonkey</title>
    <link>http://localhost:1313/cryptocave/</link>
    <description>Recent content in Cryptocaves on ShadowMonkey</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/cryptocave/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>101 Tangential Topics</title>
      <link>http://localhost:1313/cryptocave/blockchain_101_tangential/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_101_tangential/</guid>
      <description>Tangential Topics Peer-to-Peer In order to avoid centralization, Bitcoin uses a peer-to-peer architecture. Unlike in a client-server architecture, nodes in this network act both as a server that can download files and as a client that can process data and message other nodes. This does not mean that the nodes must be identical, but only that there is no hierarchy among them.&#xA;Nodes In Bitcoin there are three types of nodes: full nodes, mining nodes, and light nodes.</description>
    </item>
    <item>
      <title>Blockchain 101</title>
      <link>http://localhost:1313/cryptocave/blockchain_101/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_101/</guid>
      <description>Problem I want to send money over the internet but I don&amp;rsquo;t trust financial intermediaries.&#xA;Solution Instead of giving a financial intermediary control over the recordbook, distribute the recordbook across a network of participants.&#xA;Naive Approach How does one distribute a recordbook across a network of participants? Well, not unlike the internet itself, we can create a network of nodes (participants) that can transmit messages to one another. Each participant in the network can can store its own version of the recordbook.</description>
    </item>
    <item>
      <title>Blockchain 102 (Consensus)</title>
      <link>http://localhost:1313/cryptocave/blockchain_102/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_102/</guid>
      <description>Problem I want to send money over the internet using a distributed network but I don&amp;rsquo;t trust malicious nodes.&#xA;Solution Combine consensus protocols to create a Byzantine Fault Tolerant consensus mechanism.&#xA;Consensus can probably delete this paragraph In order to add to the ledger, transactions undergo a process to check that they’re legitimate. But, it’d be inefficient to try to process every transaction one-by-one; instead, the transactions are bundled together into blocks.</description>
    </item>
    <item>
      <title>Blockchain 103 (Bridges)</title>
      <link>http://localhost:1313/cryptocave/blockchain_103/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_103/</guid>
      <description>Problem I want to send money from one blockchain to another but I don&amp;rsquo;t trust financial intermediaries.&#xA;Solution Create a trust-minimized way for blockchains to interact.&#xA;Context A blockchain is designed to account for all possible state conditions - the combination of accounts, transactions, data, etc.. It is not designed to interpret information from other systems, the same way a store isn&amp;rsquo;t designed to accept gift cards from other stores.</description>
    </item>
    <item>
      <title>Blockchain 104 (State Machines)</title>
      <link>http://localhost:1313/cryptocave/blockchain_104/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_104/</guid>
      <description>Problem The distributed network of machines that I use is limited to sending financial transactions. I want to perform other actions with minimized trust.&#xA;Solution virtual machine&#xA;State Machines The modern concept of a blockchain is to exist as a globally replicated state machine. What this means is blockchains have been designed to run as a single machine where every user action (transaction) is interpreted relative to the state. The term ‘virtual machine (VM)’ refers to running this machine inside another, the same way one could run the Mac OS on a Windows computer using a VM.</description>
    </item>
    <item>
      <title>Blockchain 105 (dApps)</title>
      <link>http://localhost:1313/cryptocave/blockchain_105/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_105/</guid>
      <description>Problem I can write smart contracts to create trustless applications but the user experience (UX) is insufficient for mainstream adoption.&#xA;Solution dApps&#xA;Tokens https://kydo.substack.com/p/decentralization-in-dapps-vs-l1</description>
    </item>
    <item>
      <title>Blockchain 106 (Oracles)</title>
      <link>http://localhost:1313/cryptocave/blockchain_106/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_106/</guid>
      <description>Problem I can create decentralized applications but there is no way for them to interact with real-world data.&#xA;Solution Oracles</description>
    </item>
    <item>
      <title>Blockchain 107 (Sovereign Chains)</title>
      <link>http://localhost:1313/cryptocave/blockchain_107/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_107/</guid>
      <description>Problem I can&amp;rsquo;t build my own decentralized network without designing a blockchain from scratch.&#xA;Solution cosmos-sdk, polkadot, avalanche: Design a blockchain with custom consensus, validators, token / staking / inflation, custom rules, gas fees, rules built into the chain instead of smart contracts, custom execution environment / devx for developers</description>
    </item>
    <item>
      <title>Blockchain 108 (Rollups)</title>
      <link>http://localhost:1313/cryptocave/blockchain_108/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_108/</guid>
      <description>Problem Gas is expensive on Ethereum. or I want more control over my application but I still want to rely on Ethereum security.&#xA;Solution Rollups - very unfinished&#xA;Context Rollups are a clever workaround to circumvent the high gas costs of transacting on Ethereum. By compressing many transactions into calldata, a rollup can effectively run hundreds of transactions on Ethereum for the price of one. To do this, however, requires another layer (a Layer 2) where these transactions are derived to.</description>
    </item>
    <item>
      <title>Blockchain Preface</title>
      <link>http://localhost:1313/cryptocave/blockchain_0_preface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/blockchain_0_preface/</guid>
      <description>The set of articles that follow provide a foundation for understanding the world of blockchains and cryptocurrencies in the most concise, correct format I could procure. They are geared towards technical readers with little to no context of this world, but I still find them useful even as a reader with a lot of context. I refer to these articles often when elaborating on the incredible applications of ZK in the ZKWorld section.</description>
    </item>
    <item>
      <title>Cheating Single Slot Finality</title>
      <link>http://localhost:1313/cryptocave/cheating_single_slot_finality/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/cheating_single_slot_finality/</guid>
      <description>A catchy phrase that gets thrown around is ‘single slot finality’. If you’re not familiar, here are two links ordered by complexity, and an example protocol to go along: https://ethereum.org/en/roadmap/single-slot-finality/ https://notes.ethereum.org/@vbuterin/single_slot_finality https://ethresear.ch/t/a-simple-single-slot-finality-protocol/14920&#xA;The idea here being that on Ethereum we want a user’s transaction to be considered final as soon as the slot that their transaction is included in is complete. Each slot is 12 seconds. 32 slots make up an epoch, which is justified after 2/3rds of validators vote correctly on its chain head.</description>
    </item>
    <item>
      <title>Collection of Cryptographic Assumptions</title>
      <link>http://localhost:1313/cryptocave/crypto_assumptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/crypto_assumptions/</guid>
      <description>Introduction There are too many assumptions to keep track of. I keep forgetting which assumption comes from where and is applicable in what context. Cryptography is notoriously difficult to keep up with because new assumptions are constantly being proposed in order to gain more and more functionality. The goal of this page is to keep track of various assumptions as and when I read about them. They can then be referenced in the future with some clarity.</description>
    </item>
    <item>
      <title>Directory of Cryptographic Objects</title>
      <link>http://localhost:1313/cryptocave/crypto_objects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/crypto_objects/</guid>
      <description>Guide The other pain point I have found while attempting to study cryptography is that there is a vast ocean of cryptographic objects and that they are all useful for different contexts, can be constructed from different assumptions, andoffer different security guarantees. I will attempt here to keep a working directory of cryptographic objects. Where possible, I will provide an overview of their construction and an intuition for their security/efficiency guarantees.</description>
    </item>
    <item>
      <title>Elliptic Curves Part 1</title>
      <link>http://localhost:1313/cryptocave/elliptic_curves/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/elliptic_curves/</guid>
      <description>Introduction This will be a running place to try and understand elliptic curves. I don&amp;rsquo;t have a cohesive picture, but will try and keep some random notes here until I can compile them into something tangible.&#xA;Hasse&amp;rsquo;s Theorem Frobenius Endomorphism Legendre Symbol Jacobi Sums Schoof&amp;rsquo;s Algorithm Supersingular Curves Resources Elliptic Curves Over Finite Fields Ben Lynn Notes Schoof&amp;rsquo;s Algorithm </description>
    </item>
    <item>
      <title>FFT Overview</title>
      <link>http://localhost:1313/cryptocave/fft/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/fft/</guid>
      <description>Why We Care About FFTs &amp;ldquo;FFTs require linear space-complexity for the prover, and prevent the prover from being implemented in logarithmic space as in the sumcheck protocol or other succinct arguments based on folding protocols. In contrast, we reduce $\mathsf{NP}$ statements to bilinear relations such as scalar-product relations, and then rely on succinct arguments for scalar products; this reduction can be performed via a linear number of cryptographic operations, and without relying on FFTs.</description>
    </item>
    <item>
      <title>Implementing Finite Fields</title>
      <link>http://localhost:1313/cryptocave/ff_implementation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/ff_implementation/</guid>
      <description>Motivation implementing algebraic settings is incredibly important for cryptography. in particular, it is important to ensure fast operations in these settings. getting familiar with these operations and what algorithms are available for them in the context of digital architectures is useful. this is my first attempt at implementing a finite field. i&amp;rsquo;m hoping to keep notes here that document what i learn along the way.&#xA;incremental notes Reduction Algorithms or How to Choose a Modulus Modular multiplication can be done in the standard way.</description>
    </item>
    <item>
      <title>Multiscalar Multiplication (MSM)</title>
      <link>http://localhost:1313/cryptocave/msm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/msm/</guid>
      <description>Goal Useful treatment is given in Bootle&amp;rsquo;s Notes.&#xA;Pippenger&amp;rsquo;s Algorithms Pippenger&amp;rsquo;s Variants Hardward Acceleration </description>
    </item>
    <item>
      <title>notes1</title>
      <link>http://localhost:1313/cryptocave/notes1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/notes1/</guid>
      <description>Note 1 - EVM&#xA;Trust + stickiness&#xA;Why the EVM sticks&#xA;In blockchains people talk a lot about trust, and especially about minimizing trust. Truthfully, trust can only migrate, and it is a subjective measure. Many of us in the space happen to believe that humans are often the least trustworthy part of a system, and by minimizing their involvement we maximize the trustworthiness of the system (all other things equal).</description>
    </item>
    <item>
      <title>notes1</title>
      <link>http://localhost:1313/cryptocave/notes2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/notes2/</guid>
      <description>Note 2 - more direct economic security&#xA;In Bitcoin, the cost to mine a block maps to the cost of electricity. The price of Bitcoin isn’t really correlated to electricity costs, which means that the cost to mine a block has very little to do with the value of that block.&#xA;Ethereum, start with 32 stake and protocol can upgrade (as have been proposed) to adjust in the future&#xA;In Ethereum, the cost to attack the network is based on the staking and slashing rates.</description>
    </item>
    <item>
      <title>notes3</title>
      <link>http://localhost:1313/cryptocave/notes3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/notes3/</guid>
      <description>Note 3 - enshrine&#xA;Many rollups discuss the concept of enshrining logic. The idea is that if rules are baked into the protocol, the rollup benefits from better safety guarantees. Some of the tradeoffs are discussed here: https://ethresear.ch/t/why-enshrine-proposer-builder-separation-a-viable-path-to-epbs/15710&#xA;In the context of a proving marketplace, this idea has also been discussed (https://discourse.aztec.network/t/ideas-on-a-proving-network/724/3 ) . Here, it seems like the minimal requirement for a rollup is to ‘enshrine’ a delegation mechanism - we interpret this to mean that a method to request proofs from a 3rd party is baked into the protocol.</description>
    </item>
    <item>
      <title>notes4</title>
      <link>http://localhost:1313/cryptocave/notes4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/notes4/</guid>
      <description>Note 4 - Shared Sequencers&#xA;At SBC this year, there was a lot of interesting discussion about shared sequencers. Because the idea of rollups is relatively untested, there are still a lot of experimental formats for attempting to decentralize rollups such that they resemble Ethereum. On Ethereum, anyone can post a transaction request to the public mempool - this results in communication overhead to network this mempool of pending transaction requests to one another.</description>
    </item>
    <item>
      <title>notes5</title>
      <link>http://localhost:1313/cryptocave/notes5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/notes5/</guid>
      <description>Note 5 - on-chain proofs&#xA;Smart contracts have inherently been a dream of fairness and automation (it’s in the name), with the promise of executing agreements without any human involvement. As it turns out, this isn’t always useful - a lot of agreements rely on information that is not (yet) stored on blockchains. The growth of proofs being verified on-chain will be a cool test of whether this concept can be challenged while minimizing trust on other humans.</description>
    </item>
    <item>
      <title>notes6</title>
      <link>http://localhost:1313/cryptocave/notes6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/notes6/</guid>
      <description>Note 6 - Off-chain incentivization (with crypto economic security)&#xA;It seems that incentivizing off-chain activity has been a topic of discussion. Eigenlayer brought more attention to the value of crypto economic security, building a framework for others to design slashing conditions. Cowswap was able to design a mechanism where solvers operate from an off-chain orderbook to match ‘coincidence of wants’ that relies on slashing, so that solvers stake and they can be economically enforced to act correctly.</description>
    </item>
    <item>
      <title>On Cryptographic Security Models</title>
      <link>http://localhost:1313/cryptocave/on_security_models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/on_security_models/</guid>
      <description>Random Oracle Model (ROM) Models cryptographic hash functions as random oracles.&#xA;Random Beacons vs Random Oracles The difference between random beacons and the much more well-known random oracles, is that their values are not available until certain time slots. That means we can assume a given random beacon value is independent of values output by an adversary in previous time slots. (Or in the case of the adversary having influence on the beacon, beacon values have lots oentropy conditioned on previous values output by the adversary.</description>
    </item>
    <item>
      <title>Overview of the PCP Theorem</title>
      <link>http://localhost:1313/cryptocave/pcp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/pcp/</guid>
      <description>The PCP Revolution Formal Statement Proof </description>
    </item>
    <item>
      <title>Revisiting Rollup Centrism</title>
      <link>http://localhost:1313/cryptocave/revisiting_rollup_centrism/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/revisiting_rollup_centrism/</guid>
      <description>Introduction It’s been 3 years since Vitalik’s post on A rollup-centric Ethereum roadmap. In it, he described the long-term future for eth2 as: a single high-security execution shard that everyone processes, plus a scalable data availability layer. This roadmap laid out an evolution of functionality from Ethereum as a platform for smart contracts (Prehistory) to a base layer that would scale blockchains for the next billion users. It was a great culmination of his thinking on base layers from a year prior (Base Layers and Functional Escape Velocity), which extended ideas about the roles of layer 1s and layer 2s another year earlier (Layer 1s should be innovative in the short term but less in the long term).</description>
    </item>
    <item>
      <title>Some Paper Notes</title>
      <link>http://localhost:1313/cryptocave/paper_notes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/cryptocave/paper_notes/</guid>
      <description>Lattices Practical Exact Proofs from Lattices: New Techniques to Exploit Fully-Splitting Rings Motivation/Overview&#xA;Goal: prove knowledge of secret vector $s$ that satisfies $As = t$, where $A$ and $t$ are public. $A \in \mathbb{Z}^{m \times n}$, $t \in \mathbb{Z}^{m}$, $s \in \langle-1, 0, 1\rangle^{n}$. What we will really mean is that $A$ is a matrix of polynomials in $\mathcal{R}_{q}$ over some basis in $\mathbb{Z}_{q}$. $t$ is a polynomial vector and $s$ is a short polynomial vector &amp;ndash; that is, its coefficients are themselves ternary polynomials.</description>
    </item>
  </channel>
</rss>
